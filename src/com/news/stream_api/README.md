
#Stream API
[часть 1](https://m.habrahabr.ru/post/302628) **|** [часть 2](http://javadevblog.com/polnoe-rukovodstvo-po-java-8-stream.html) **|** [часть 3](https://habrahabr.ru/company/luxoft/blog/270383)


> — используется для работы с коллекциями, позволяя писать код в функциональном стиле.

###Способы создания стримов
> Вызов метода stream() по перечню объектов возвращает поток.
Есть:
— примитивные потоки (IntStream, LongStream и DoubleStream + IntFunction, IntPredicate)
— и объектные потоки (Stream)

| №  |                                                        |                                         | Пример |
| --- | ------------------------------------------------------ | --------------------------------------- | ------ |
| 1.  | collection.stream()                                    | из коллекции                            |        |
| 2.  | collection.parallelStream()                            | параллельного стрима (из коллекции)     |        |
|     |                                                        |                                         |        |
| 3.  | Arrays.stream(массив)                                  | из массива                              |        |
| 4.  | "строка".chars()                                       | из строки                               |        |
| 5.  | Stream.of(значение1, ..., значениеN)                   | из значений                             |        |
| 6.  | Files.lines(путь_к_файлу)                              | из файла                                |        |
|     |                                                        |                                         |        |
| 7.  | Stream.builder().add(...)....build()                   | через Stream.builder                    |        |
| 8.  | Stream.iterate(начальное_условие, выражение_генерации) | бесконечный стрим через Stream.iterate  |        |
| 9.  | Stream.generate(выражение_генерации)                   | бесконечный стрим через Stream.generate |        |


###Методы работы со стримами
---
1. **Конвейерные** — возвращают другой *stream* **(** то есть работают как *builder* **)**
> У *stream'a* может быть сколько угодно много *конвейерных* вызовов и в конце один вызов *терминальный*.
> Все *конвейерные методы* выполняются лениво и пока не будет вызван *терминальный метод* - никаких действий на самом деле не происходит (этот механизм похож на конструирования SQL запросов)!
2. **Терминальные** — возвращают другой *объект* **(** такой как коллекция, примитивы, объекты, Optional и ... **)**

```java
    /**
     * filter и skip — конвейерные
     * findFirst — терминальный (он возвращает объект Optional и это заканчивает работу со stream'ом)
     */
    collection.stream()
        .filter((s) -> s.contains("1"))
        .skip(2)
        .findFirst();

```

Конвейерные методы работы со стримами:

| (Метод stream)                                                          | Описание                                                          | Пример |
| ----------------------------------------------------------------------- | ----------------------------------------------------------------- | ------ |
| .`map`((s) -> s + "_1").collect(Collectors.toList());                   | Преобразует каждый элемент стрима                                 |        |
| `mapToInt`, `mapToDouble`, `mapToLong`                                  | Аналог map, но возвращает числовой стрим                          |        |
| .`peek`((e) -> System.out.print("," + e)).collect(Collectors.toList()); | Возвращает тот же стрим и применяет функцию к каждому элементу    |        |
| .`filter`("a1"::equals).count();                                        | Возвращает записи которые соответствуют условию                   |        |
| .`skip`(collection.size() - 1).findFirst().orElse(0);                   | Позволяет пропустить N-первых элементов                           |        |
| .`limit`(2).collect(Collectors.toList());                               | ограничивает выборку для количества первых элементов              |        |
| .`sorted`().collect(Collectors.toList());                               | сортировать значения                                              |        |
| .`distinct`().collect(Collectors.toList());                             | Возвращает стрим без дубликатов                                   |        |
|                                                                         |                                                                   |        |
| `flatMap`, `flatMapToInt`, `flatMapToDouble`, `flatMapToLong`           | Похоже на map, но может создавать из одного элемента несколько    |        |


Терминальные методы работы со стримами:

| (Метод stream)                                                | Описание                                                                    | Пример |
| ------------------------------------------------------------- | --------------------------------------------------------------------------- | ------ |
| .`forEach`((p) -> p.append("_1"));                            | Применяет функцию к каждому объекту стрима                                  |        |
| .`forEachOrdered`((p) -> p.append("_1"));                     | Применяет функцию к каждому объекту стрима, сохраняет порядок элементов     |        |
| .filter((s) -> s.contains(1)).`collect`(Collectors.toList()); | Возвращает (превращает) результат в виде коллекций (List, Set, Map)         |        |
| .map(String::toUpperCase).`toArray`(String[]::new);           | Возвращает стрим как массив                                                 |        |
| .`reduce`((s1, s2) -> s1 + s2).orElse(0);                     | Выполняет агрегатные функции на всей коллекцией и возвращать один результат |        |
| .`min`(String::compareTo).get();                              | Возвращает минимальный элемент, в качестве условия использует компаратор    |        |
| .`max`(String::compareTo).get();                              | Возвращает максимальный элемент, в качестве условия использует компаратор   |        |
| .`findFirst`().orElse(0);                                     | Возвращает первый элемент из стрима                                         |        |
| .filter("a1"::equals).`count`();                              | Возвращает количество элементов в стриме                                    |        |
| .`anyMatch`("a1"::equals);                                    | Возвращает *true* если условие выполняется хотя бы для одного элемента      |        |
| .`noneMatch`("a8"::equals);                                   | Возвращает *true* если условие НЕ выполняется ни для одного элемента        |        |
| .`allMatch`((s) -> s.contains(1));                            | Возвращает *true* если условие выполняется для всех элементов               |        |
| .`findAny`().orElse(0);                                       | Возвращает любой подходящий элемент из стрима                               |        |


###Повторное использование Потоков (Streams)

> (Потоки в Java 8 не могут быть использованы повторно)
> Как только вызываете какую-нибудь *терминальную* операцию - поток закрывается.

```java
    Stream<String> stream = Stream.of("dd2", "aa2", "bb1", "bb3", "cc")
                                .filter(s -> s.startsWith("a"));

    stream.anyMatch(s -> true);    // операция выполнится успешно
    stream.noneMatch(s -> true);   // Вылетит Exception
```

Вызов noneMatch после anyMatch в одном и том же stream вызовет следующее исключение:

```java
Exception in thread "main" java.lang.IllegalStateException: stream has already been operated upon or closed
	at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:229)
	at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:459)
```


Чтобы избежать этого, мы должны создать новую цепь для каждой *терминальной* операции:

```java
    Supplier<Stream<String>> streamSupplier = () -> Stream.of("dd2", "aa2", "bb1", "bb3", "cc")
                                                        .filter(s -> s.startsWith("a"));

    streamSupplier.get().anyMatch(s -> true);   // операция пройдет успешно
    streamSupplier.get().noneMatch(s -> true);  // здесь также все будет ok
```

    Каждый вызов конструктора get() создает новый поток, с которым мы можем безопасно работать.


###Порядок обработки
- **Последовательный** (sequential)
- **Параллельный** (parallel)

> Потоки могут быть выполнены параллельно, чтобы увеличить производительность выполнения на большом количестве входных элементов.
>
> Параллельные потоки используют общий `ForkJoinPool` доступный через статический `ForkJoinPool.commonPool()` метод.
>
> *Размер основного пула потоков использует до 5-и нитей — в зависимости от количества доступных физических ядер процессора*:

