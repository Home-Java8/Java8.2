
#Лямбда-выражения
* [habrahabr.ru/post/224593](https://habrahabr.ru/post/224593)
* [info.javarush.ru/translation/2014/10/09/Особенности-Java-8-максимальное-руководство-часть-1-.html](http://info.javarush.ru/translation/2014/10/09/Особенности-Java-8-максимальное-руководство-часть-1-.html)
---
    Лямбда-выражение является блоком кода с параметрами.
    Используйте лямбда-выражение, когда хотите выполнить блок кода в более поздний момент времени.
    Лямбда-выражения могут быть преобразованы в функциональные интерфейсы.
    Лямбда-выражения имеют доступ к final переменным из охватывающей области видимости.
    Ссылки на метод и конструктор ссылаются на методы или конструкторы без их вызова.
    Теперь вы можете добавить методы по умолчанию и статические методы к интерфейсам, которые обеспечивают конкретные реализации.
    Вы должны разрешать любые конфликты между методами по умолчанию из нескольких интерфейсов.

***Функциональный интерфейс*** — это интерфейс с только одним методом (в результате он может быть неявно преобразован в *лямбда-выражение*).
> *java.lang.Runnable* и *java.util.concurrent.Callable* два замечательных примера функциональных интерфейсов

***@FunctionalInterface*** — (на практике функциональные интерфейсы очень хрупки: если кто-то добавит хотя бы один другой метод в определение интерфейса, он не будет больше функциональным и процесс компиляции не завершится) чтобы избежать хрупкости и явно определить намерения интерфейса как функционального.

###Интерфейсы по умолчанию и статические методы
***Методы по умолчанию*** — делают интерфейсы несколько похожими на *трейты*, (но служат немного другой цели) они позволяют добавлять новые методы к существующим интерфейсам не нарушая обратную совместимость для ранее написанных версий этих интерфейсов.
> Разница между *методами по умолчанию* и *абстрактными методами* в том что: *абстрактные методы* — должны быть реализованы; а *методы по умолчанию* — нет;

######Особенность в Java 8:
* Каждый интерфейс должен предоставить реализацию по умолчанию, и все наследники будут получать ее по умолчанию (с возможностью переопределить эту реализацию по умолчанию при необходимости).

```java
    private interface Defaulable {
        // Интерфейсы теперь разрешают методы по умолчанию,
        // клиент может реализовывать  (переопределять)
        // или не реализовывать его
        default String notRequired() {
            return "Default implementation";
        }
    }

    private static class DefaultableImpl implements Defaulable {
    }

    private static class OverridableImpl implements Defaulable {
        @Override
        public String notRequired() {
            return "Overridden implementation";
        }
    }
```

* Интерфейсы могут объявлять и предлагать реализацию для статических методов (особенность в Java 8):

```java
    private interface DefaulableFactory {
        static Defaulable create( Supplier< Defaulable > supplier ) {
            return supplier.get();
        }
    }
```


###Ссылочные методы:
1) ссылка на конструктор с синтаксисом ***Class::new*** ( или альтернативный для дженериков (generics) ***Class< T >::new*** )
```java
    final Car car = Car.create( Car::new );
    final List< Car > cars = Arrays.asList( car );
```

2) это ссылка на статический метод с синтаксисом ***Class::static_method*** ( Обратите внимание, что метод принимает ровно один параметр типа-Car )
```java
    cars.forEach( Car::collide );
```

3) ссылка на метод экземпляра произвольного объекта определенного типа с синтаксисом ***Class::method*** ( Обратите внимание, что никакие аргументы не принимаются методом )
```java
    cars.forEach( Car::repair );
```

4) ссылка на метод экземпляра определенного класса с синтаксисом ***instance::method*** ( Обратите внимание, что метод принимает только один параметр типа-Car )
```java
    final Car police = Car.create( Car::new );
    cars.forEach( police::follow );
```


